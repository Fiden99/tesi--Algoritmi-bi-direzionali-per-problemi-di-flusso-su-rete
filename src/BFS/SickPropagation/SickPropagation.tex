\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}

\title{SickPropagation}
\author{Filippo Magi }

\begin{document}

\maketitle

\section{Propagazione della malattia}
\begin{algorithm}
\caption{Ricerca del massimo flusso a costo minimo con propagazione della malattia}
\begin{algorithmic}
\REQUIRE grafo dei residui $\overset{\leftrightarrow}{G} = \{V(G),E(G) \cup \{ \overset{\leftarrow}{e} : e \in E(G) \}$ .
\ENSURE valore del flusso massimo
\STATE s $\leftarrow$ SourceNode di $\overset{\leftrightarrow}{G}$
\STATE t $\leftarrow$ SinkNode di $\overset{\leftrightarrow}{G}$
\STATE noCap $\leftarrow$ null
\LOOP
\STATE f $\leftarrow$ DoBfs(grafo,noCap)
\IF{ f = 0}
\STATE \textbf{break}
\ENDIF
\STATE mom $\leftarrow$ t
\WHILE{ mom $\ne$ s}
\STATE aggiorno capacità o flusso del nodo m a seconda del suo predecessore
\IF{capacità dell'arco (m,predecossore di m) = 0}
\STATE noCap $\leftarrow$ mom
\ENDIF
\STATE mom $\leftarrow$ predecessore di mom
\ENDWHILE
\ENDLOOP
\RETURN flusso uscente da s
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{DoBfs con propagazione della malattia}
\begin{algorithmic}
\REQUIRE grafo dei residui $\overset{\leftrightarrow}{G}$, nodo noCap
\ENSURE flusso inviato al nodo t, $\overset{\leftrightarrow}{G}$ aggiornato
\STATE coda $\leftarrow$ coda vuota di nodi
\IF{noCap = null}
\STATE coda.enqueue(sourceNode di $\overset{\leftrightarrow}{G}$)
\ELSE
\STATE t $\leftarrow$ SinkNode di $\overset{\leftrightarrow}{G}$
\STATE provo a riparare noCap \COMMENT {controllo se c'è un nodo con label = noCap.label-1 e con capacità o flusso diversa da 0}
\IF {noCap è stato riparato AND il flusso entrante nel predecessore di t $\ne 0$ AND capacità dell'arco (t, predecessore di t) $> 0$}
\RETURN Min(flusso entrante di t, flusso passante per noCap)
\ENDIF
\STATE v $\leftarrow$ SickPropagation(grafo,noCap,coda)
\IF{v $\ne 0$}
\RETURN v
\ENDIF
\STATE cancello il flusso entrante nei nodi con label $\leq$ noCap.label
\IF{coda è vuota}
\STATE coda $\leftarrow$ nodi di $\overset{\leftrightarrow}{G}$ con label = (noCap.label - 1)
\ENDIF
\FORALL{ nodo n $\in$ coda}
\STATE recupera flusso entrante dall'ultimo nodo che lo ha 
\COMMENT{Dato che è possibile che il flusso entrante sia uguale a zero dovuto a SickPropagation, torno indietro fino al primo nodo con flusso entrante positivo, quindi, ricorsivamente, inserisco il flusso entrante per tutti i nodi che ho visitato}
\ENDFOR
\ENDIF
\WHILE{la coda non è vuota}
\STATE element $\leftarrow$ code.Dequeue()
\FORALL{edge $\leftarrow$ archi che escono ed entrano in element}
\STATE n $\leftarrow$ nodo che entra da edge
\STATE p $\leftarrow$ nodo che esce da edge
\IF{n ed p sono stati visitati (se il nodo è invalido è considerato non visitato)}
\STATE \textbf{continue}
\ENDIF
\IF{p = element AND capacità di edge $>0$ AND (n è successivo a p OR n non è valido OR noCap = null)}
\STATE aggiorno i dati di n (label, flusso entrante, nodo precedente, nel caso riparo il nodo)
\IF{ n è  SinkNode di $\overset{\leftrightarrow}{G}$}
\RETURN flusso entrante in n
\ELSE
\STATE coda.enqueue(n)
\ENDIF
\ELSIF{n = element AND flusso di edge $>0$ AND p non è stato visitato}
\STATE aggiorno i dati di p
\IF{ p è  SinkNode di $\overset{\leftrightarrow}{G}$}
\RETURN flusso entrante in n
\ELSE
\STATE coda.enqueue(p)
\ENDIF
\ENDIF
\ENDFOR
\ENDWHILE
\RETURN 0

\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{SickPropagation}
\begin{algorithmic}
\REQUIRE grafo dei residui $\overset{\leftrightarrow}{G}$, Nodo node, coda di nodi
\ENSURE possibile flusso inviato verso t (partendo da n,conoscendo i valori antecedenti a n), 0 altrimenti

\STATE malati $\leftarrow$ coda di nodi
\STATE malati.Enqueue(node);
\WHILE{malati non è vuota}
\STATE m $\leftarrow$ malati.Dequeue()
\STATE provo a riparare m
\IF{il nodo non è stato riparato}
\STATE malati.enqueue(nodo con previousNode = m)
\ELSIF{m è SinkNode di $\overset{\leftrightarrow}{G}$}
\STATE v $\leftarrow$ ricorsivamente, dal sourceNode di $\overset{\leftrightarrow}{G}$ ottengo il flusso massimo che posso inviare,salvando il flusso entrante per ogni arco (recuperato tramite previousNode) che attraverso
\RETURN v
\ELSE
\STATE coda.enqueue(m)
\ENDIF
\ENDWHILE
\RETURN 0
\end{algorithmic}
\end{algorithm}
\end{document}