\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}

\title{Algoritmo che analizza solo le label potenzialmente modificate}
\author{Filippo Magi }

\begin{document}

\maketitle

\section{Ottimizzazione sulle ultime label}
\begin{algorithm}
    \caption{Ricerca del massimo flusso a costo minimo con ricalcolo solo nelle ultime label}
    \begin{algorithmic}
    \REQUIRE grafo dei residui $\overset{\leftrightarrow}{G} = \{V(G),E(G) \cup \{ \overset{\leftarrow}{e} : e \in E(G) \}$ .
    \ENSURE valore del flusso massimo
    \STATE s $\leftarrow$ SourceNode di $\overset{\leftrightarrow}{G}$
    \STATE t $\leftarrow$ SinkNode di $\overset{\leftrightarrow}{G}$
    \STATE noCap $\leftarrow$ null
    \LOOP
    \STATE f $\leftarrow$ DoBfs(grafo,noCap)
    \IF{ f = 0}
    \STATE \textbf{break}
    \ENDIF
    \STATE mom $\leftarrow$ t
    \WHILE{ mom $\ne$ s}
    \STATE aggiorno capacità o flusso del nodo m a seconda del suo predecessore
    \IF{capacità dell'arco (m,predecossore di m) = 0}
    \STATE noCap $\leftarrow$ mom
    \ENDIF
    \STATE mom $\leftarrow$ predecessore di mom
    \ENDWHILE
    \ENDLOOP
    \RETURN flusso uscente da s
    \end{algorithmic}
    \end{algorithm}
    
    
    \begin{algorithm}
    \caption{Algoritmo DoBfs con ottimizzazione solo nelle ultime label}
    \begin{algorithmic}
    \REQUIRE grafo dei residui $\overset{\leftrightarrow}{G}$, nodo noCap
    \ENSURE valore del flusso inviato al SinkNode, $\overset{\leftrightarrow}{G}$ aggiornato
    \STATE coda $\leftarrow$ coda vuota di nodi
    \IF{noCap = null}
    \STATE coda.Enqueue(source nodo di $\overset{\leftrightarrow}{G}$
    \ELSE
    \STATE rendo invalido noCap
    \STATE provo a riparare noCap /*controllo se c'è un nodo con label = noCap.label-1 e con capacità o flusso diversa da 0*/
    \STATE t $\leftarrow$ SinkNode di $\overset{\leftrightarrow}{G}$
    \IF {noCap è stato riparato AND il flusso entrante nel predecessore di t $\ne 0$ AND capacità dell'arco (t, predecessore di t) $> 0$}
    \RETURN Min(flusso entrante di t, flusso passante per noCap)
    \ENDIF
    \STATE coda $\leftarrow$ nodi di $\overset{\leftrightarrow}{G}$ con label = (noCap.label - 1)
    \STATE cancello informazioni contenute nei nodi con label $\leq$ noCap.label
    \FORALL{ nodo n $\in$ coda}
    \STATE controllo che flusso inviato di n sia legale con precedessori di n
    \COMMENT{ analizzo se il predecessore abbia flusso entrate $\ge$ flusso entrante di n, in questo caso termina, altrimenti continua coi i predecessori, da valutare se deve arrivare fino a n o se basta che incontri il primo nodo con flusso legale, CorrectFlow nel codice}
    \ENDFOR
    \ENDIF
    \WHILE{la coda non è vuota}
    \STATE element  $\leftarrow$ coda.dequeue()
    \FORALL{edge che entrano o escono da element}
    \STATE n $\leftarrow$ nodo dove edge entra
    \STATE p $\leftarrow$ nodo dove edge esce
    \IF{element è valido (cioè la label è corretta)}
    \IF{ p = element  AND capacità di edge $> 0$ AND (n non è stato esplorato OR n non è valido)}
    \STATE aggiorno dati di n \COMMENT{label, flusso entrante e nodo precedente, nel caso sia necessario "riparo" il nodo}
    \IF {n è SinkNode di $\overset{\leftrightarrow}{G}$}
    \RETURN flusso entrante di n
    \ELSE
    \STATE coda.Enqueue(n)
    \ENDIF
    \IF{n = element AND flusso di edge $> 0$ AND (p non è stato esplorato OR p non è valido)}
    \STATE aggiorno i dati di p
    \STATE aggiorno edge indicando che deve essere percorso in senso opposto
    \IF{p è SinkNode di  $\overset{\leftrightarrow}{G}$}
    \RETURN flusso entrante di p
    \ELSE
    \STATE coda.Enqueue(p)
    \ENDIF
    \ENDIF
    \ENDIF
    \ENDIF
    \ENDFOR
    \ENDWHILE
    \RETURN 0
    \end{algorithmic}
    \end{algorithm} 
\end{document}    