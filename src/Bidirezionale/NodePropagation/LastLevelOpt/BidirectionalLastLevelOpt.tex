\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{algorithm}
%\usepackage{algorithmic}
\usepackage{algcompatible}
\usepackage{amsmath}

\title{algoritmi bidirezionali}
\author{Filippo Magi }

\begin{document}

\maketitle
\section{Ottimizzazione sugli ultimi livelli}
\subsection{FlowFordFulkerson}
\begin{algorithm}
    \caption{Ricerca del flusso massimo}
    \begin{algorithmic}[1]
        \REQUIRE rete $(G,u,s,t)$
        \ENSURE valore del flusso massimo
        \STATE $vuotoSouce \leftarrow s $
        \STATE $vuotoSink \leftarrow t$
        \STATE $fMax \leftarrow 0$
        \WHILE{TRUE}
        \STATE $(f,n) \leftarrow$ DoBfs(G, vuotoSource,vuotoSink)
        \IF{$f = 0$}
        \STATE \textbf{break}
        \ENDIF
        \STATE $fMax \leftarrow fMax + f$
        \STATE $vuotoSouce \leftarrow$ null
        \STATE $vuotoSink \leftarrow$ null
        %TODO migliorare questo stato, spiegando meglio e in meno parole la seguente istruzione n.SetInFlow(n.InFlow + f);
        \STATE $n$.flussoPassante $\leftarrow n.$flussoPassante + $n$.flussoPassante
        \STATE $momSource \leftarrow n$
        \STATE $momSink \leftarrow n$
        \WHILE{$momSource \ne s$}
        \STATE $momSource$.previousEdge.addFlow$(f)$
        \IF{$u(momSource$.previousEdge $) < 0$ OR $f(momSource$.previousEdge )$ < 0$ }
        \STATE $vuotoSource \leftarrow momsource$
        \STATE $momsource$.revert() \COMMENT{faccio tornare i dati a come erano prima dell'aggiornamento (fMax, valori di flusso passante e archi modificati)}
        \STATE $sourceReverted \leftarrow$ true
        \STATE $fMax \leftarrow fMax - f$
        \STATE \textbf{break}
        \ELSE
        \IF{$u(momSource$.previousEdge$) = 0$}
        \STATE $momSource$.valid = false
        \STATE $vuotoSource \leftarrow momSource$
        \ENDIF
        \STATE $momSource.$flussoPassante $\leftarrow momSource.$flussoPassante-f
        \STATE $momSource \leftarrow momSource.$previousNode
        \ENDIF
        \ENDWHILE
        \IF{$\neg sourceReverted$}
        \WHILE{ $momSink \ne t$}
        \STATE $momSink$.nextEdge.addFlow($f$)
        \IF{$u(momSink.$nextEdge)$ <0$ OR $f(momSink.$nextEdge)$ <0$ }
        \STATE $vuotoSink \leftarrow momSink$
        \STATE $momSink$.revert()
        \STATE \textbf{break}
        \ELSE
        \IF{ $u(momSink.$nextEdge$) = 0$}
        \STATE $momSink.$valid $\leftarrow$ false
        \STATE $vuotoSink \leftarrow momSink$
        \STATE $fMax \leftarrow fMax - f$
        \ENDIF
        \STATE $momSink$.flussoPassante $\leftarrow$ $momSink$.flussoPassante $-f$
        \STATE $momSink \leftarrow momSink.$nextNode
        \ENDIF
        \ENDWHILE
        \ENDIF
        \ENDWHILE
        \STATE \textbf{return} $fMax$
    \end{algorithmic}
\end{algorithm}

\subsection{DoBfs}
\begin{algorithm}
    \caption{DoBfs con ottimizzazione sugli ultimi livelli}
    \begin{algorithmic}[1]
        \REQUIRE rete $(G,u,s,t)$, $noCapSource, noCapSink$, cioè nodi,rispettivamente della parte sorgente e della parte destinazione, che non sono più raggiungili dal percorso deciso precedentemente
        \ENSURE valore del flusso inviabile, nodo appartenente LastSinkNodes, cioè tutti i nodi che sono intermedi che fanno da ponte tra le due ricerche.
        \STATE $codaSource \leftarrow$ coda di nodi vuota
        \STATE $codaSink \leftarrow$ coda di nodi vuota
        \IF{$noCapSource \ne$ null}
        \STATE Repair($noCapSource$
        \IF{riesco a riparare $noCapSource$}
        \IF{$noCapSink = $null}
        \FORALL{$n \in $ LastSinkNodes $ | n.valid$  }
        \STATE GetFlow$(noCapSource,n)$ \COMMENT{da n cerco di retrocedere verso noCapSource, aggiornando ricorsivamente le informazioni dei nodi in modo opportuno (sopratutto per quanto riguarda n)}
        \IF {percorso legale tra $n$ e $noCapSource$ AND  $ \forall e |e \in$ percorso tra $n$ e $noCapSource, u(e) > 0$}
        \STATE \textbf{return} ($n$.flussoPassante,$n$)
        \ENDIF
        \ENDFOR
        \ELSE
        \STATE $sourceRepaired \leftarrow$ true
        \ENDIF
        \ENDIF
        \IF{$noCapSource = s$}
        \STATE $coda.$enqueue($noCapSource$)
        \ELSIF {$noCapSource \in $ LastSinkNodes}
        \STATE $codaSource \leftarrow$ LastSourceNodes \COMMENT{nodi collegati ai nodi di LastSinkNodes}
        \ELSE
        \STATE $codaSource \leftarrow$ nodi esplorati da source con label = noCapSource.label-1
        \FORALL{$n \in N(G) | $esplorati da source AND $n.label \ge noCapSource.label$}
        \STATE $n.$reset()
        \ENDFOR
        \ENDIF
        \ENDIF
        \algstore{LastLevelOptNoCapSourceInit}

    \end{algorithmic}
\end{algorithm}

\newpage

\begin{algorithm}
    \begin{algorithmic}[1]
        \algrestore{LastLevelOptNoCapSourceInit}
        \IF{$noCapSink \ne$ null}
        \STATE Repair($noCapSink$)
        \IF{riesco a riparare $noCapSink$}
        \STATE $sinkRepaired \leftarrow$ true
        \IF{$sourceRepaired$ OR $noCapSource = $ null}
        \FORALL{$n \in N(G) |n.$valid AND $n \in $LastSinkNodes }
        \IF{$sourceRepaired$}
        \IF{da n posso ricorsivamente retrocedere verso noCapSource (GetFlow)}
        \STATE $sourceFlow \leftarrow n$.flussoPassante
        \ELSE
        \STATE \textbf{continue}
        \ENDIF
        \ELSE
        \STATE $sourceFlow \leftarrow$ $\min$($n$.previousNode.flussoPassante,$u(n.PreviousEdge)$ \COMMENT{nel caso in cui arco.reversed = true, devo controllare il flusso e non la capacità residua} )
        \ENDIF
        \IF{$sourceFlow > 0$ AND n può retrocedere ricorsivamente verso noCapSink(Getflow) AND $n.$flussoPassante $> 0$ }
        \STATE \textbf{return} ($\min(n.$flussoPassante$, sourceFlow),n)$
            \ENDIF
            \ENDFOR
            \ENDIF
            \ENDIF
            \IF{$noCapSink=t$}
            \STATE $codaSink.$enqueue($noCapSink$)
            \ELSE
            \STATE $codaSink \leftarrow$ nodi esplorati da sink con label = noCapSink.label-1
            \FORALL{$n \in N(G) | $ esplorati da sink AND $n.label \ge noCapSink.label$}
            \STATE $n.$reset()
        \ENDFOR
        \ENDIF
        \ENDIF
        \algstore{LastLevelOptNoCapSinkInit}

    \end{algorithmic}
\end{algorithm}

\newpage

\begin{algorithm}
    \begin{algorithmic}[1]
        \algrestore{LastLevelOptNoCapSinkInit}
        \WHILE{$\neg codaSink$.isEmpty OR $\neg codaSource.$isEmpty}
        \IF{$\neg codaSource$.isEmpty AND ($noCapSource \ne$ null OR $\neg sourceRepaired$}
        \STATE$ element \leftarrow codaSource$.dequeue()
        \IF{$\neg element$.sourceSide OR $\neg element.$valid }
        \STATE \textbf{continue}
        \ENDIF
        \FORALL{ $edge \in element.Edges$}
        \STATE $p \leftarrow edge$.previousNode
        \STATE $n \leftarrow edge$.nextNode
        \IF{$element = p $AND $u(edge)> 0$}
        \IF{$n$.visited}
        \IF{$n$.sourceside (esplorato da source)}
        \STATE \textbf{continue}
        \ELSE \Comment{in questo caso ho le due parti che si incontrano}
        \STATE $f \leftarrow \min(n.flussoPassante,p.flussoPassante,u(edge))$
        \IF{$f = 0$}
        \STATE \textbf{continue}
        \ENDIF
        \STATE $n.$update$(p,edge)$
        \STATE $edge.reversed \leftarrow $ false
        \STATE LastNodesSinkSide.add(n) \COMMENT{di conseguenza inserisco tutti i nodi collegati direttamente a n che fanno parte di SourceSide in LastNodesSourceSide}
        \STATE \textbf{return} $(f,n)$
        \ENDIF
        \ENDIF
        \IF{$\neg n.sourceSide$ AND $n \ne t$}
        \STATE $sinkRepaired \leftarrow$ false
        \FORALL{ $node \in N(G) |\neg node.sourceSide $ AND $node.label = (n.label - 1)$}
        \STATE $codaSink.$enqueue($node$)
        \ENDFOR
        \FORALL{$node \in N(G) |\neg node.sourceSide $ AND $node.label \ge n.label$}
        \STATE $node.$reset()
        \ENDFOR
        \STATE \textbf{continue}
        \ENDIF
        \STATE $n.$update($p,edge$)
        \STATE $codaSource$.enqueue($n$)
        \algstore{finishedSourceSideCap}
    \end{algorithmic}
\end{algorithm}
\newpage
\begin{algorithm}
    \begin{algorithmic}
        \algrestore{finishedSourceSideCap}
        \ELSIF {$element = n $ AND $f(edge)>0$}
        \IF{$p$.visited}
        \IF{$p$.sourceside}
        \STATE\textbf{continue}
        \ELSE
        \STATE $f \leftarrow \min (n.flussoPassante,p.flussoPassante,f(edge))$
        \IF{$f = 0$}
        \STATE \textbf{continue}
        \ENDIF
        \STATE $p.$update(n,edge)
        \STATE $edge.reversed \leftarrow$ true
        \STATE \textbf{return } $(f,p)$
        \ENDIF
        \ENDIF
        \IF{$\neg p$.sourceSide AND $p \ne  t$}
        \STATE $sinkRepaired \leftarrow$ false
        \FORALL{$ node \in V(G) | \neg node.sourceNode $AND$ node.label = (p.label-1)$}
        \STATE $codaSink$.enqueue($node$)
        \ENDFOR
        \FORALL{$node \in V(G) |\neg node.sourceSide $ AND $node.label \ge p.label$}
        \STATE $node.$reset()
        \ENDFOR
        \STATE\textbf{continue}
        \ENDIF
        \STATE $p$.update$(n,edge)$
        \STATE $edge.reversed \leftarrow$ true
        \STATE $codaSource.$enqueue$(p)$
        \ENDIF
        \ENDFOR
        \ENDIF
        \algstore{FinishedSourcePart}
    \end{algorithmic}
\end{algorithm}
\newpage
\begin{algorithm}
    \begin{algorithmic}
        \algrestore{FinishedSourcePart}
        \IF{$\neg codaSink$.isEmptyAND  ($noCapSink \ne$ null OR $\neg sinkRepaired$)}
        \STATE $element \leftarrow codaSink.$dequeue()
        \IF{$element.sourceSide$ OR $\neg element.valid$}
        \STATE \textbf{continue}
        \ENDIF

        \FORALL{ $edge \in element.Edges$}
        \STATE $p \leftarrow edge.$previousNode
        \STATE $n \leftarrow edge$.nextNode
        \IF{$element = n$ AND  $u(edge)> 0 $}
        \IF{$p$.visited}
        \IF{$\neg p.$sourceSide}
        \STATE \textbf{continue}
        \ELSE
        \IF{$sourceRepaired$ AND  n può retrocedere ricorsivamente verso noCapSink(GetFlow) AND $n.$flussoPassante$ > 0$}
        \STATE $f \leftarrow \min (n.nextNode.flussoPassante, n.flussoPassante) $
        \STATE $f \leftarrow \min(f,n.PreviousNode.flussoPassante, u(n.nextEdge), u(n.previuosEdge))$
        \COMMENT{qui se edge.reversed = true va considerato il flusso f e non la capacità residua u}
        \IF{$f > 0$ }
        \STATE \textbf{return} $f$
        \ENDIF
        \ENDIF
        \STATE $f \leftarrow \min (n.flussoPassante,p.flussoPassante,u(edge))$
        \IF{$f = 0$}
        \STATE \textbf{continue}
        \ENDIF
        \STATE $n$.update$(p,edge)$
        \STATE $edge.reversed \leftarrow $false
        \STATE \textbf{return} $(f,n)$
        \ENDIF
        \ENDIF
        \IF{$p.$sourceSide AND $noCapSink \ne t$}
        \STATE \textbf{continue}
        \ENDIF
        \STATE $p.$update$(n,edge)$
        \STATE $edge.reversed \leftarrow$ false
        \STATE $codaSink.$enqueue$(p)$
        \algstore{FinishSinkElementN}
    \end{algorithmic}
\end{algorithm}
\newpage
\begin{algorithm}
    \begin{algorithmic}
        \algrestore{FinishSinkElementN}
        \ELSIF{$element = p $AND $f(edge)>0$}
        \IF{$p.$visited}
        \IF{$\neg p.$sourceSide}
        \STATE \textbf{continue}
        \ELSE
        \IF{$sourceRepaired $ AND da p riesco a raggiungere noCapSource(GetFlow)}
        \STATE \textbf{return} $(p.flussoPassante,p)$
        \ENDIF
        \STATE $f \leftarrow \min(p.flussoPassante,n.flussoPassante,f(edge))$
        \IF{$f = 0$}
        \STATE \textbf{continue}
        \ENDIF
        \STATE $p.$update$(n,edge)$
        \STATE $edge.reversed \leftarrow$ true
        \STATE \textbf{return } $(f,p)$
        \ENDIF
        \ENDIF
        \IF{$n.$sourceSide AND $n \ne t$}
        \STATE \textbf{continue}
        \ENDIF
        \STATE $n.$update$(p,edge)$
        \STATE $edge.reversed \leftarrow$ true
        \STATE $codaSink.$enqueue$(n)$
        \ENDIF
        \ENDFOR
        \ENDIF
        \ENDWHILE
        \STATE \textbf{return} $(0,null)$
    \end{algorithmic}
\end{algorithm}
\end{document}