\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}

\title{algoritmi}
\author{Filippo Magi }

\begin{document}

\maketitle

\section{Algoritmo senza ottimizzazione}

\begin{algorithm}
\caption{Ricerca del massimo flusso a costo minimo senza alcuna ottimizzazione}
\begin{algorithmic}
\REQUIRE grafo dei residui $\overset{\leftrightarrow}{G} = \{V(G),E(G) \cup \{ \overset{\leftarrow}{e} : e \in E(G) \}$ .
\ENSURE valore del flusso massimo
\STATE s $\leftarrow$ SourceNode di  $\overset{\leftrightarrow}{G}$
\STATE t $\leftarrow$ SinkNode di  $\overset{\leftrightarrow}{G}$
\LOOP
\STATE f $\leftarrow$ DoBfs(grafo)
\IF{ f = 0}
\STATE \textbf{break}
\ENDIF
\STATE mom $\leftarrow$ t
\WHILE{ mom $\ne$ s}
\STATE aggiorno capacità o flusso del nodo m a seconda del suo predecessore
\STATE mom $\leftarrow$ predecessore di mom
\ENDWHILE
\ENDLOOP
\RETURN flusso uscente da s

\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Algoritmo DoBfs senza alcuna ottimizzazione}
\begin{algorithmic}
\REQUIRE grafo dei residui $\overset{\leftrightarrow}{G}$
\ENSURE quantità di flusso inviata, grafo dei residui $\overset{\leftrightarrow}{G}$ aggiornato per cammino $f$ aumentante
\STATE cancella informazioni precedenti presenti in $V(G)$
\STATE coda $\leftarrow$ Coda di nodi
\STATE coda.Enqueue(SoruceNode di $\overset{\leftrightarrow}{G}$)
\WHILE{coda non è vuota }
\STATE element $\leftarrow$ coda.Dequeue
\FORALL{arco \textbf{edge} che esce dal nodo element}
\STATE n $\leftarrow$ nodo che entra da edge
\IF{nodo n non è già stato visitato  AND è possibile inviare(o ritirare) del flusso }
\STATE aggiorno dati di n (nodo precedente, label, flusso entrante)
\IF{n è il SinkNode di $\overset{\leftrightarrow}{G}$}
\RETURN flusso entrante in n
\ELSE
\STATE coda.Enqueue(n)
\ENDIF
\ENDIF
\ENDFOR
\ENDWHILE
\RETURN 0
\end{algorithmic}
\end{algorithm}

\section{Ottimizzazione sono nelle ultime label}
\begin{algorithm}
\caption{Ricerca del massimo flusso a costo minimo con ricalcolo solo nelle ultime label}
\begin{algorithmic}
\REQUIRE grafo dei residui $\overset{\leftrightarrow}{G} = \{V(G),E(G) \cup \{ \overset{\leftarrow}{e} : e \in E(G) \}$ .
\ENSURE valore del flusso massimo
\STATE s $\leftarrow$ SourceNode di $\overset{\leftrightarrow}{G}$
\STATE t $\leftarrow$ SinkNode di $\overset{\leftrightarrow}{G}$
\STATE noCap $\leftarrow$ null
\LOOP
\STATE f $\leftarrow$ DoBfs(grafo,noCap)
\IF{ f = 0}
\STATE \textbf{break}
\ENDIF
\STATE mom $\leftarrow$ t
\WHILE{ mom $\ne$ s}
\STATE aggiorno capacità o flusso del nodo m a seconda del suo predecessore
\IF{capacità dell'arco (m,predecossore di m) = 0}
\STATE noCap $\leftarrow$ mom
\ENDIF
\STATE mom $\leftarrow$ predecessore di mom
\ENDWHILE
\ENDLOOP
\RETURN flusso uscente da s
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Algoritmo DoBfs con ottimizzazione solo nelle ultime label}
\begin{algorithmic}
\REQUIRE grafo dei residui $\overset{\leftrightarrow}{G}$, nodo noCap
\ENSURE valore del flusso inviato al SinkNode, $\overset{\leftrightarrow}{G}$ aggiornato
\STATE coda $\leftarrow$ coda vuota di nodi
\IF{noCap = null}
\STATE coda.Enqueue(source nodo di $\overset{\leftrightarrow}{G}$
\ELSE
\STATE rendo invalido noCap
\STATE provo a riparare noCap /*controllo se c'è un nodo con label = noCap.label-1 e con capacità o flusso diversa da 0*/
\STATE t $\leftarrow$ SinkNode di $\overset{\leftrightarrow}{G}$
\IF {noCap è stato riparato AND il flusso entrante nel predecessore di t $\ne 0$ AND capacità dell'arco (t, predecessore di t) $> 0$}
\RETURN Min(flusso entrante di t, flusso passante per noCap)
\ENDIF
\STATE coda $\leftarrow$ nodi di $\overset{\leftrightarrow}{G}$ con label = (noCap.label - 1)
\STATE cancello informazioni contenute nei nodi con label $\leq$ noCap.label
\FORALL{ nodo n $\in$ coda}
\STATE controllo che flusso inviato di n sia legale con precedessori di n
\COMMENT{ analizzo se il predecessore abbia flusso entrate $\ge$ flusso entrante di n, in questo caso termina, altrimenti continua coi i predecessori, da valutare se deve arrivare fino a n o se basta che incontri il primo nodo con flusso legale, CorrectFlow nel codice}
\ENDFOR
\ENDIF
\WHILE{la coda non è vuota}
\STATE element  $\leftarrow$ coda.dequeue()
\FORALL{edge che entrano o escono da element}
\STATE n $\leftarrow$ nodo dove edge entra
\STATE p $\leftarrow$ nodo dove edge esce
\IF{element è valido (cioè la label è corretta)}
\IF{ p = element  AND capacità di edge $> 0$ AND (n non è stato esplorato OR n non è valido)}
\STATE aggiorno dati di n \COMMENT{label, flusso entrante e nodo precedente, nel caso sia necessario "riparo" il nodo}
\IF {n è SinkNode di $\overset{\leftrightarrow}{G}$}
\RETURN flusso entrante di n
\ELSE
\STATE coda.Enqueue(n)
\ENDIF
\IF{n = element AND flusso di edge $> 0$ AND (p non è stato esplorato OR p non è valido)}
\STATE aggiorno i dati di p
\STATE aggiorno edge indicando che deve essere percorso in senso opposto
\IF{p è SinkNode di  $\overset{\leftrightarrow}{G}$}
\RETURN flusso entrante di p
\ELSE
\STATE coda.Enqueue(p)
\ENDIF
\ENDIF
\ENDIF
\ENDIF
\ENDFOR
\ENDWHILE
\RETURN 0
\end{algorithmic}
\end{algorithm} 

\section{Propagazione della malattia}
\begin{algorithm}
\caption{Ricerca del massimo flusso a costo minimo con propagazione della malattia}
\begin{algorithmic}
\REQUIRE grafo dei residui $\overset{\leftrightarrow}{G} = \{V(G),E(G) \cup \{ \overset{\leftarrow}{e} : e \in E(G) \}$ .
\ENSURE valore del flusso massimo
\STATE s $\leftarrow$ SourceNode di $\overset{\leftrightarrow}{G}$
\STATE t $\leftarrow$ SinkNode di $\overset{\leftrightarrow}{G}$
\STATE noCap $\leftarrow$ null
\LOOP
\STATE f $\leftarrow$ DoBfs(grafo,noCap)
\IF{ f = 0}
\STATE \textbf{break}
\ENDIF
\STATE mom $\leftarrow$ t
\WHILE{ mom $\ne$ s}
\STATE aggiorno capacità o flusso del nodo m a seconda del suo predecessore
\IF{capacità dell'arco (m,predecossore di m) = 0}
\STATE noCap $\leftarrow$ mom
\ENDIF
\STATE mom $\leftarrow$ predecessore di mom
\ENDWHILE
\ENDLOOP
\RETURN flusso uscente da s
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{DoBfs con propagazione della malattia}
\begin{algorithmic}
\REQUIRE grafo dei residui $\overset{\leftrightarrow}{G}$, nodo noCap
\ENSURE flusso inviato al nodo t, $\overset{\leftrightarrow}{G}$ aggiornato
\STATE coda $\leftarrow$ coda vuota di nodi
\IF{noCap = null}
\STATE coda.enqueue(sourceNode di $\overset{\leftrightarrow}{G}$)
\ELSE
\STATE t $\leftarrow$ SinkNode di $\overset{\leftrightarrow}{G}$
\STATE provo a riparare noCap \COMMENT {controllo se c'è un nodo con label = noCap.label-1 e con capacità o flusso diversa da 0}
\IF {noCap è stato riparato AND il flusso entrante nel predecessore di t $\ne 0$ AND capacità dell'arco (t, predecessore di t) $> 0$}
\RETURN Min(flusso entrante di t, flusso passante per noCap)
\ENDIF
\STATE v $\leftarrow$ SickPropagation(grafo,noCap,coda)
\IF{v $\ne 0$}
\RETURN v
\ENDIF
\STATE cancello il flusso entrante nei nodi con label $\leq$ noCap.label
\IF{coda è vuota}
\STATE coda $\leftarrow$ nodi di $\overset{\leftrightarrow}{G}$ con label = (noCap.label - 1)
\ENDIF
\FORALL{ nodo n $\in$ coda}
\STATE recupera flusso entrante dall'ultimo nodo che lo ha 
\COMMENT{Dato che è possibile che il flusso entrante sia uguale a zero dovuto a SickPropagation, torno indietro fino al primo nodo con flusso entrante positivo, quindi, ricorsivamente, inserisco il flusso entrante per tutti i nodi che ho visitato}
\ENDFOR
\ENDIF
\WHILE{la coda non è vuota}
\STATE element $\leftarrow$ code.Dequeue()
\FORALL{edge $\leftarrow$ archi che escono ed entrano in element}
\STATE n $\leftarrow$ nodo che entra da edge
\STATE p $\leftarrow$ nodo che esce da edge
\IF{n ed p sono stati visitati (se il nodo è invalido è considerato non visitato)}
\STATE \textbf{continue}
\ENDIF
\IF{p = element AND capacità di edge $>0$ AND (n è successivo a p OR n non è valido OR noCap = null)}
\STATE aggiorno i dati di n (label, flusso entrante, nodo precedente, nel caso riparo il nodo)
\IF{ n è  SinkNode di $\overset{\leftrightarrow}{G}$}
\RETURN flusso entrante in n
\ELSE
\STATE coda.enqueue(n)
\ENDIF
\ELSIF{n = element AND flusso di edge $>0$ AND p non è stato visitato}
\STATE aggiorno i dati di p
\IF{ p è  SinkNode di $\overset{\leftrightarrow}{G}$}
\RETURN flusso entrante in n
\ELSE
\STATE coda.enqueue(p)
\ENDIF
\ENDIF
\ENDFOR
\ENDWHILE
\RETURN 0

\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{SickPropagation}
\begin{algorithmic}
\REQUIRE grafo dei residui $\overset{\leftrightarrow}{G}$, Nodo node, coda di nodi
\ENSURE possibile flusso inviato verso t (partendo da n,conoscendo i valori antecedenti a n), 0 altrimenti

\STATE malati $\leftarrow$ coda di nodi
\STATE malati.Enqueue(node);
\WHILE{malati non è vuota}
\STATE m $\leftarrow$ malati.Dequeue()
\STATE provo a riparare m
\IF{il nodo non è stato riparato}
\STATE malati.enqueue(nodo con previousNode = m)
\ELSIF{m è SinkNode di $\overset{\leftrightarrow}{G}$}
\STATE v $\leftarrow$ ricorsivamente, dal sourceNode di $\overset{\leftrightarrow}{G}$ ottengo il flusso massimo che posso inviare,salvando il flusso entrante per ogni arco (recuperato tramite previousNode) che attraverso
\RETURN v
\ELSE
\STATE coda.enqueue(m)
\ENDIF
\ENDWHILE
\RETURN 0
\end{algorithmic}
\end{algorithm}
\section{Shortest Augmenting Path}
\begin{algorithm}
\caption{Shortest Augmenting Path}
\begin{algorithmic}
\REQUIRE grafo dei reisidui $\overset{\leftrightarrow}{G}$
\ENSURE flusso massimo inviato, $\overset{\leftrightarrow}{G}$ aggiornato
\STATE s $\leftarrow$ nodo sorgente di $\overset{\leftrightarrow}{G}$
\STATE t $\leftarrow$ nodo destinazione di $\overset{\leftrightarrow}{G}$
\STATE eseguo bfs, che parte da t, assegnando a ogni nodo la distanza da t 
\STATE invio flusso nel percorso deciso dalla bfs
\STATE flussoInviato $\leftarrow$ flusso inviato (dal percorso deciso dalla bfs)
\WHILE{distanza tra t e s < numero di nodi di $\overset{\leftrightarrow}{G}$}
\STATE f $\leftarrow$ Dfs$(\overset{\leftrightarrow}{G}, s, +\infty)$
\IF{f $ne 0$}
\STATE invia flusso f nel grafo nel percorso indicato
\ELSE
\STATE \textbf{break}
\ENDIF
\STATE flussoInviato $\leftarrow$ f + flussoInviato 
\ENDWHILE
\RETURN flussoInviato
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{Dfs per trovare il flusso massimo in Shortest Augmenting Path}
\begin{algorithmic}
\REQUIRE grafo dei residui  $\overset{\leftrightarrow}{G}$,Nodo start, valore f
\ENSURE valore del flusso inviabile, percorso percoribile per poter inviare il flusso prima indicato
\IF{distanza tra nodo start e t < numero dei nodi presenti in $\overset{\leftrightarrow}{G}$}
\FORALL{arco edge che entra o esce nel nodo start}
\IF{edge è un arco uscente da start ed edge è ammissibile (distanza tra i nodi = 1 e capacità residua positiva)}
\STATE aggiorno dati di n
\STATE f $\leftarrow \min$(f,capacità di edge)
\IF{n è il nodo di destinazione di $\overset{\leftrightarrow}{G}$}
\RETURN f
\ENDIF
\RETURN Dfs($\overset{\leftrightarrow}{G}$,n,f)
\ELSIF{edge è arco entrante verso start ed edge è ammissibile (distanza tra i nodi = 1 e flusso inviato positivo)}
\STATE aggiorno dati di p
\STATE f $\leftarrow \min$(f, flusso di edge)
\IF{p è il nodo di destinazione di $\overset{\leftrightarrow}{G}$}
\RETURN f
\ENDIF
\RETURN Dfs($\overset{\leftrightarrow}{G}$,p,f)
\ENDIF
\ENDFOR
\STATE min $\leftarrow +\infty$
\FORALL{arco edge che entra in start}
\IF{flusso di edge è positivo}
\STATE min $\leftarrow \min$(min, flusso di edge)
\ENDIF
\ENDFOR
\FORALL{arco edge che esce da start}
\IF{capacità di edge è positiva}
\STATE min $\leftarrow \min$(min, capacità di edge)
\ENDIF
\ENDFOR
\STATE distanza tra start e t $\leftarrow$ min
\IF{start è nodo sorgente di $\overset{\leftrightarrow}{G}$}
\RETURN Dfs($\overset{\leftrightarrow}{G}$,start,f)
\ELSE
\RETURN Dfs($\overset{\leftrightarrow}{G}$,predecessore di start,f)
\ENDIF
\ENDIF
\RETURN 0
\end{algorithmic}
\end{algorithm}

\end{document}
